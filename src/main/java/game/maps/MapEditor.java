/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package game.maps;

import game.maps.MapEditor.CustomPanel;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.util.LinkedList;
import javax.swing.JFrame;

/**
 *
 * @author cookiebot
 */
public final class MapEditor extends javax.swing.JFrame {

    /**
     * Creates new form MapEditor
     */
    private Map[] maps;
    private Map map;
    private MapHitbox hitbox;
    private Rectangle zone;
    public boolean zoneSelected = false;

    private int mapSelected = 0;
    private int hitboxSelected = 0;
    CustomMouse mouse;
    CustomKeyboard keyboard;

    public MapEditor() {
        mouse = new CustomMouse();
        this.addMouseListener(mouse);
        this.addMouseMotionListener(mouse);
        keyboard = new CustomKeyboard();
        this.addKeyListener(keyboard);
        initComponents();
        maps = Map.getMaps();
        setMap(0);
        setHitbox(0);
        ((CustomPanel)panel).init();
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }
    
    public void setMap(int mapSelected){
        map = maps[mapSelected];
    }
    public Map map(){
        if(map == null)
            return maps[0];
        return map;
    }
    public void selectNewMap(){
        mapSelected = (mapSelected + 1)%maps.length;
    }
    
    public void setHitbox(int hitboxSelected){
        this.hitboxSelected = hitboxSelected;
        try {
            if(hitboxSelected < map().hitboxes.size()){
                zone = null;
                zoneSelected = false;
                hitbox = map().hitboxes.get(hitboxSelected);
            }
            else{
                hitbox = null;
                zoneSelected = true;
                zone = map().zones.get(hitboxSelected-map().hitboxes.size());
            }
        }
        catch (Exception e){
            System.out.println("could not set hitbox");
            e.printStackTrace();
        }
    }
    
    public void selectNewHitbox(){
        hitboxSelected ++;
        if(hitboxSelected >= map().hitboxes.size()+map().zones.size()){
            hitboxSelected = 0;
        }
        setHitbox(hitboxSelected);
    }
    
    public void remove(){
        hitbox = null;
        zone = null;
        if(hitboxSelected < map().hitboxes.size()){
            map().hitboxes.remove(hitboxSelected);
        }
        else{
            map().zones.remove(hitboxSelected-map().hitboxes.size());
        }
    }
    
    public MapHitbox hitbox(){
        if(zoneSelected || hitbox == null)return new MapHitbox(0,0,100,100);
        return hitbox;
    }
    
    public Rectangle zone(){
        if(!zoneSelected || zone == null)return new Rectangle(0,0,100,100);
        return zone;
    }
    
    public void setZone(Rectangle r){
        if(!zoneSelected)return;
        map().zones.set(hitboxSelected-map().hitboxes.size(),r);
    }
    
    public boolean isHitboxSelected(int index){
        return index == hitboxSelected;
    }
    
    public boolean isZoneSelected(int index){
        return index == hitboxSelected-map().hitboxes.size();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        panel = new CustomPanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setBackground(new java.awt.Color(50, 50, 50));

        javax.swing.GroupLayout panelLayout = new javax.swing.GroupLayout(panel);
        panel.setLayout(panelLayout);
        panelLayout.setHorizontalGroup(
            panelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 726, Short.MAX_VALUE)
        );
        panelLayout.setVerticalGroup(
            panelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 503, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(panel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(panel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(6, 6, 6))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(MapEditor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(MapEditor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(MapEditor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MapEditor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new MapEditor().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel panel;
    // End of variables declaration//GEN-END:variables

    // Custom JPanel class for drawing
    class CustomPanel extends javax.swing.JPanel {

        private int selected;
        int offsetX = 0;
        int offsetY = 0;

        public void init(){
            offsetX = map().width/2;
            offsetY = map().height/2;
            repaint();
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            Graphics2D g2d = (Graphics2D) g;
            g2d.setStroke(new BasicStroke(3));
            g2d.translate(offsetX, offsetY);

            g.setColor(new Color(240, 240, 240));
            g.fillRect(0, 0, getWidth(), getHeight());
            g2d.drawImage(map().background, -map().width/2, -map().height/2, this);
            g2d.setColor(new Color(255, 255, 0, 100));
            g2d.fillOval(mouse.offX - 20, mouse.offY - 20, 40, 40);
            g2d.drawImage(map().foreground, -map().width/2, -map().height/2, this);
            for (int i = 0; i < map().hitboxes.size(); i++) {
                MapHitbox hitbox = map().hitboxes.get(i);
                hitbox.render(g2d, isHitboxSelected(i));
            }
            for (int i = 0; i < map().zones.size(); i++) {
                Rectangle h = map().zones.get(i);
                g.setColor(Color.green);
                g.drawRect(h.x,h.y,h.width,h.height);
                if(isZoneSelected(i)){
                    g.setColor(new Color(0,255,0,50));
                    g.fillRect(h.x,h.y,h.width,h.height);
                }
            }
            if (mouse.drawingHitbox) {
                g2d.setColor(new Color(255, 0, 0, 200));
                int centerX = (mouse.offX + mouse.hitboxStart.x) / 2;
                int centerY = (mouse.offY + mouse.hitboxStart.y) / 2;
                int width = Math.abs(mouse.offX - mouse.hitboxStart.x);
                int height = Math.abs(mouse.offY - mouse.hitboxStart.y);

                g2d.drawRect(centerX - width / 2, centerY - height / 2, width, height);
            }
        }
        
        public void drag(int offx, int offy){
            offx *= 0.9f;
            offy *= 0.9f;
            offsetX += offx;
            offsetY += offy;
            offsetX = Math.min(offsetX, map().width/2);
            offsetY = Math.min(offsetY, map().height/2);
            offsetX = Math.max(offsetX, this.getWidth()- map().width/2);
            offsetY = Math.max(offsetY, this.getHeight()- map().height/2);
        }
    }
    class CustomKeyboard implements KeyListener {

        int lastPressed;
        int lastTyped;
        LinkedList<Integer> currentlyPressedKeys;

        public CustomKeyboard(){
            currentlyPressedKeys = new LinkedList<>();
            lastPressed = 0;
            lastTyped = 0;
        }

        @Override
        public void keyTyped(KeyEvent ke) {
            lastTyped = ke.getKeyCode();
            currentlyPressedKeys.remove(Integer.valueOf(ke.getKeyCode()));
            
        }

        @Override
        public void keyPressed(KeyEvent ke) {
            lastPressed = ke.getKeyCode();
            if(!currentlyPressedKeys.contains(ke.getKeyCode()))
                currentlyPressedKeys.add(ke.getKeyCode());
            
            if(ke.getKeyCode() ==KeyEvent.VK_DELETE){
                remove();
                selectNewHitbox();
                panel.repaint();
                return;
            }
            
            if(ke.getKeyCode() ==KeyEvent.VK_S && currentlyPressedKeys.contains(KeyEvent.VK_CONTROL)){
                map().writeToFile();
                panel.repaint();
                return;
            }
            
            if(ke.getKeyCode() ==KeyEvent.VK_ENTER||ke.getKeyCode() ==KeyEvent.VK_SHIFT){
                selectNewHitbox();
                panel.repaint();
                return;
            }
            if(ke.getKeyCode() ==KeyEvent.VK_ENTER && currentlyPressedKeys.contains(KeyEvent.VK_CONTROL)){
                map().writeToFile();
                selectNewMap();
                panel.repaint();
                return;
            }
            
            int xmove = 0;
            int ymove = 0;
            int wmove = 0;
            int hmove = 0;
            
            if(ke.getKeyCode() == KeyEvent.VK_LEFT){
                xmove --;
            }
            if(ke.getKeyCode() == KeyEvent.VK_RIGHT){
                xmove ++;
            }
            if(ke.getKeyCode() == KeyEvent.VK_UP){
                ymove --;
            }
            if(ke.getKeyCode() == KeyEvent.VK_DOWN){
                ymove ++;
            }
            if(currentlyPressedKeys.contains(KeyEvent.VK_ALT)){
                wmove = xmove;
                hmove = ymove;
                xmove = 0;
                ymove = 0;
            }
            if(xmove != 0 || ymove != 0 || wmove != 0 || hmove != 0){
                if(!zoneSelected){
                    hitbox().shift(xmove, ymove, wmove, hmove);
                }
                else{
                    Rectangle r = zone();
                    r.width += xmove;
                    r.height += ymove;
                    r.x += wmove;
                    r.y += hmove;
                    setZone(r);
                }
            }
            
            int rot = 0;
            
            if(ke.getKeyCode() == KeyEvent.VK_EQUALS){
                rot = 1;
            }
            else if(ke.getKeyCode() == KeyEvent.VK_MINUS){
                rot = -1;
            }
            if(currentlyPressedKeys.contains(KeyEvent.VK_SHIFT)){
                rot *= 10;
            }
            if(rot != 0 && hitbox.type == 2){
                hitbox.rotate(rot);
            }
            
            panel.repaint();
        }

        @Override
        public void keyReleased(KeyEvent ke) {
            lastTyped = ke.getKeyCode();
            currentlyPressedKeys.remove(Integer.valueOf(ke.getKeyCode()));
        }

        public boolean pressed(int ke){
            return currentlyPressedKeys.contains(ke);
        }

        public int getLastPressed() {
            return lastPressed;
        }

        public int clearTyped() {
            int holder = lastTyped;
            lastTyped = 0;
            return holder;
        }
        public int clearPressed() {
            int holder = lastPressed;
            lastPressed = 0;
            return holder;
        }
        public int getLastTyped() {
            return lastTyped;
        }

        public LinkedList<Integer> getCurrentlyPressedKeys() {
            return currentlyPressedKeys;
        }

    }

    class CustomMouse implements MouseListener, MouseMotionListener, MouseWheelListener {

        int X, Y;
        int offX, offY;

        boolean drawingHitbox = false;
        Point hitboxStart = new Point(0, 0);

        boolean draggingScreen = false;
        Point lastDragged;

        @Override
        public void mouseClicked(MouseEvent me) {}

        @Override
        public void mousePressed(MouseEvent me) {
            if (me.getButton() == MouseEvent.BUTTON3) {
                hitboxStart = new Point(offX, offY);
                drawingHitbox = true;
            }
            else if (me.getButton() == MouseEvent.BUTTON1) {
                lastDragged = new Point(X, Y);
                draggingScreen = true;
            }
            panel.repaint();
        }

        @Override
        public void mouseReleased(MouseEvent me) {

            if (me.getButton() == MouseEvent.BUTTON3) {
                
                int code = 0;
                if(!keyboard.getCurrentlyPressedKeys().isEmpty())
                    code = keyboard.getCurrentlyPressedKeys().get(0) - KeyEvent.VK_1;
                
                if(code == -1){
                    map().addHitbox(code, (hitboxStart.x + offX ) / 2 - Math.abs(hitboxStart.x - offX)/2,
                            (hitboxStart.y + offY) / 2 - Math.abs(hitboxStart.y - offY)/2,
                            Math.abs(hitboxStart.x - offX), Math.abs(hitboxStart.y - offY));
                }
                else {
                    map().addHitbox(code, (hitboxStart.x + offX) / 2, (hitboxStart.y + offY) / 2,
                            Math.abs(hitboxStart.x - offX), Math.abs(hitboxStart.y - offY));
                    setHitbox(map().hitboxes.size()-1);
                }
                drawingHitbox = false;
            }
            else if (me.getButton() == MouseEvent.BUTTON1) {
                lastDragged = new Point(offX, offY);
                draggingScreen = false;
            }
            
            panel.repaint();
        }

        @Override
        public void mouseEntered(MouseEvent me) {}

        @Override
        public void mouseExited(MouseEvent me) {}

        @Override
        public void mouseDragged(MouseEvent me) {
            X = me.getX();
            Y = me.getY();
            offX = X - ((CustomPanel)panel).offsetX-6;
            offY = Y - ((CustomPanel)panel).offsetY-6;
            panel.repaint();
            if(draggingScreen){
                ((CustomPanel)panel).drag(X-lastDragged.x,Y-lastDragged.y);
                lastDragged = new Point(X, Y);
            }
        }

        @Override
        public void mouseMoved(MouseEvent me) {
            X = me.getX();
            Y = me.getY();
            offX = X - ((CustomPanel)panel).offsetX-6;
            offY = Y - ((CustomPanel)panel).offsetY-6;
            panel.repaint();
        }

        @Override
        public void mouseWheelMoved(MouseWheelEvent mwe) {
            int scrAmt = mwe.getScrollAmount();
            if (mwe.getWheelRotation() < 0) {
                scrAmt *= -1;
            }
        }
    }
}
